#version 440 core
layout(local_size_x = 1, local_size_y = 1, local_size_z = 16) in;

struct Chunk{
    vec3 pos;
};

struct Voxel{
    int voxType;
    int isSolid;
};

struct Vertex{
    float x;
    float y;
    float z;
};

struct Colour{
    float r;
    float g;
    float b;
    float a;
};

// Chunk Data
layout(binding = 3) buffer chunk_data {

    Chunk chunk[];
};

// Vertices Data
layout(binding = 1) buffer vertices_out {

    Vertex vertices[];
};

// Vertex Colour Data
layout(binding = 2) buffer vertexColours_out {

    Colour vertex_colours[];
};

// Voxel Data (data for each voxel in the chunk)
layout(binding = 0) buffer voxel_data {

    Voxel voxels[];
};

// Apply greedy meshing to the specified sequence of faces
void greedyMeshFaces(int x, int y, int z, int storedPos, int chainLength, int faceIndex){

    // Store the current and stored face vertex information
    Vertex stored_vertices[6];
    Vertex curr_vertices[6];

    // Apply Greedy Meshing to a Front, Back, Left or Right Face
    if(faceIndex == 0 || faceIndex == 2 || faceIndex == 3 || faceIndex == 1){

        // Remove all of the old vertices and store the vertex information of the storedFace and the face it leads to
        for(int i = storedPos; i <= storedPos + chainLength; i++){
            for(int j = (faceIndex * 6); j < (faceIndex * 6) + 6; j++){

                // Determine the invocation position of the current face
                int currInvPos = int(z + 16 * (i + 16 * x));

                // Check if we should be updating the stored_vertices
                if(i == storedPos){
                    int index = j - (faceIndex * 6);
                    stored_vertices[index] = vertices[(currInvPos * 36) + j];
                }

                // Check if we should be updating the curr_vertices
                if(i == storedPos + chainLength){
                    int index = j - (faceIndex * 6);
                    curr_vertices[index] = vertices[(currInvPos * 36) + j];
                }

                Vertex blankV = {0, 0, 0};
                vertices[(currInvPos * 36) + j] = blankV;
            }
        }

        // Front Face Greedy Meshing Alterations
        if(faceIndex == 0){
            int storedInvocationPos = int(z + 16 * ((storedPos) + 16 * x));
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 0] = stored_vertices[0];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 1] = stored_vertices[1];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 2] = curr_vertices[2];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 3] = curr_vertices[3];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 4] = curr_vertices[4];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 5] = stored_vertices[5];
        }

        // Back Face Greedy Meshing Alterations
        if(faceIndex == 2){
            int storedInvocationPos = int(z + 16 * ((storedPos) + 16 * x));
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 0] = curr_vertices[0];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 1] = curr_vertices[1];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 2] = stored_vertices[2];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 3] = stored_vertices[3];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 4] = stored_vertices[4];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 5] = curr_vertices[5];
        }

        // Left Face Greedy Meshing Alterations
        if(faceIndex == 3){
            int storedInvocationPos = int(z + 16 * ((storedPos) + 16 * x));
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 0] = stored_vertices[0];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 1] = stored_vertices[1];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 2] = curr_vertices[2];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 3] = curr_vertices[3];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 4] = curr_vertices[4];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 5] = stored_vertices[5];
        }

        // Right Face Greedy Meshing Alterations
        if(faceIndex == 1){
            int storedInvocationPos = int(z + 16 * ((storedPos) + 16 * x));
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 0] = stored_vertices[0];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 1] = stored_vertices[1];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 2] = curr_vertices[2];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 3] = curr_vertices[3];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 4] = curr_vertices[4];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 5] = stored_vertices[5];
        }
    }

    // Apply Greedy Meshing to a Top or Bottom Face
    if(faceIndex == 5 || faceIndex == 4){

        // Remove all of the old vertices and store the vertex information of the storedFace and the face it leads to
        for(int i = storedPos; i <= storedPos + chainLength; i++){
            for(int j = (faceIndex * 6); j < (faceIndex * 6) + 6; j++){

                // Determine the invocation position of the current face
                int currInvPos = int(i + 16 * (y + 16 * x));

                // Check if we should be updating the stored_vertices
                if(i == storedPos){
                    int index = j - (faceIndex * 6);
                    stored_vertices[index] = vertices[(currInvPos * 36) + j];
                }

                // Check if we should be updating the curr_vertices
                if(i == storedPos + chainLength){
                    int index = j - (faceIndex * 6);
                    curr_vertices[index] = vertices[(currInvPos * 36) + j];
                }

                Vertex blankV = {0, 0, 0};
                vertices[(currInvPos * 36) + j] = blankV;
            }
        }

        // Top Face Greedy Meshing Alterations
        if(faceIndex == 5){
            int storedInvocationPos = int((storedPos) + 16 * (y + 16 * x));
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 0] = curr_vertices[0];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 1] = curr_vertices[1];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 2] = stored_vertices[2];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 3] = stored_vertices[3];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 4] = stored_vertices[4];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 5] = curr_vertices[5];
        }

        // Bottom Face Greedy Meshing Alterations
        if(faceIndex == 4){
            int storedInvocationPos = int((storedPos) + 16 * (y + 16 * x));
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 0] = stored_vertices[0];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 1] = stored_vertices[1];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 2] = curr_vertices[2];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 3] = curr_vertices[3];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 4] = curr_vertices[4];
            vertices[(storedInvocationPos * 36) + (faceIndex * 6) + 5] = stored_vertices[5];
        }
    }
}

// The cpu calls this shader with only 6x1x1 dispatch then this shader calls for 1x1x16 work groups
void main(){


    for(int i = 0; i < 16; i++){

        bool stored = false; // Whether or not a face is actually stored at the moment
        int storedType; // Type of voxel that the stored face is
        int storedPos; // Index position in relation to j that the stored face is
        int chainLength; // Chained length of adjacent faces of same voxel type

        for (int j = 0; j < 16; j++){

            // Current Face Index (Dispatch Position)
            int faceIndex = int(gl_WorkGroupID.x); // xIndex (dispatchIndex) refers to the face direction which is currently being greedy meshed

            // Vertical Greedy Meshing Logic
            if(faceIndex == 0 || faceIndex == 2 || faceIndex == 3 || faceIndex == 1 || faceIndex == 5 || faceIndex == 4){

                // Setup coordinate variables
                int x;
                int y;
                int z;

                // Setup coordinates - Front, Back, Left and Right Faces
                if(faceIndex == 0 || faceIndex == 2 || faceIndex == 3 || faceIndex == 1){
                    x = i;
                    y = j;
                    z = int(gl_LocalInvocationID.z);
                }

                // Setup coordinates - Top and Bottom
                if(faceIndex == 5 || faceIndex == 4){
                    x = i;
                    y = int(gl_LocalInvocationID.z);
                    z = j;
                }

                // Get the position of the current voxel
                int invocationPos = int(z + 16 * (y + 16 * x)); // Voxels flattened position
                Voxel currVoxel = voxels[invocationPos];

                // Determine whether this face is currently being rendered
                bool faceRendering = false;
                vec3 prevFaceVertexPosition;
                for(int l = (faceIndex * 6); l < (faceIndex * 6) + 6; l++){

                    if(vec3(vertices[(invocationPos * 36) + l].x, vertices[(invocationPos * 36) + l].y, vertices[(invocationPos * 36) + l].z) != prevFaceVertexPosition){

                        faceRendering = true;
                        break;
                    }
                   prevFaceVertexPosition = vec3(vertices[(invocationPos * 36) + l].x, vertices[(invocationPos * 36) + l].y, vertices[(invocationPos * 36) + l].z);
                }

                // Check if a faces voxel information is currently stored or not
                if(stored == false){

                    // Check if the current face is being rendered
                    if(faceRendering == true){

                        // Since the face is rendering update the stored face information to reflect this faces data
                        storedPos = j;
                        storedType = currVoxel.voxType;
                        chainLength = 0;
                        stored = true;
                        continue;
                    }else{

                        // Since the face is not rendering don't do anything during this iteration
                        continue;
                    }
                }

                // Check if the current face's voxel type is the same as the stored face's voxel type
                if(currVoxel.voxType == storedType){

                    // Check if the face is currently rendering
                    if(faceRendering == true){

                        // Check if it is the last iteration of this subsection of loop
                        if(j == 15){

                            // Since this is the last sub-loop apply increment chainLength to account for this face then greedy meshing
                            chainLength++;
                            greedyMeshFaces(x, y, z, storedPos, chainLength, faceIndex);
                        }else{

                            // Since this isn't last iteration of sub-loop increase chainLength and go to next iteration of loop
                            chainLength++;
                            continue;
                        }
                    }else{

                        // Since the face isn't rendering check if the chainLength is greater than 0 to see if meshing must be done
                        if(chainLength > 0){

                            // Length is greater than 0 so should apply greedy meshing
                            greedyMeshFaces(x, y, z, storedPos, chainLength, faceIndex);
                        }

                        // Set stored to false since this face isn't rendering and reset all stored data
                        storedPos = 0;
                        storedType = 0;
                        chainLength = 0;
                        stored = false;
                    }
                }else{

                    // since voxel types are not the same check if the chainLength is greater than 0 to see if meshing must be done
                    if(chainLength > 0){

                        // Length is greater than 0 so should apply greedy meshing
                        greedyMeshFaces(x, y, z, storedPos, chainLength, faceIndex);

                        // Check if the face is rendering
                        if(faceRendering){

                            // Face is rendering so update all stored variables with this faces data
                            storedPos = j;
                            storedType = currVoxel.voxType;
                            chainLength = 0;
                            stored = true;
                        }else{

                            // Since face isn't rendering set stored to false and reset all stored data
                            storedPos = 0;
                            storedType = 0;
                            chainLength = 0;
                            stored = false;
                        }
                    }
                }
            }
        }
    }
}