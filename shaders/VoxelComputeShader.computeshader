#version 440 core
layout(local_size_x = 1, local_size_y = 16, local_size_z = 16) in;

struct Chunk{
    vec3 pos;
};

struct Voxel{
    int voxType;
    int isSolid;
};

struct Vertex{
    float x;
    float y;
    float z;
};

struct Colour{
    float r;
    float g;
    float b;
    float a;
};

// Chunk Data
layout(binding = 3) buffer chunk_data {

    Chunk chunk[];
};

// Voxel Data (data for each voxel in the chunk)
layout(binding = 0) buffer voxel_data {

    Voxel voxels[];
};

// Vertices Data
layout(binding = 1) buffer vertices_out {

    Vertex vertices[];
};

// Vertex Colour Data
layout(binding = 2) buffer vertexColours_out {

    Colour vertex_colours[];
};

// Source: OpenGL_Programming - Modern_OpenGL_Tutorial_05
float voxel_vertices[] = {  -0.5, -0.5,  0.5,
                            0.5, -0.5,  0.5,
                            0.5,  0.5,  0.5,
                            -0.5,  0.5,  0.5,
                            -0.5, -0.5, -0.5,
                            0.5, -0.5, -0.5,
                            0.5,  0.5, -0.5,
                            -0.5,  0.5, -0.5};

int voxel_faces[] = {0, 1, 2, // Front
                     2, 3, 0,
                     1, 5, 6, // Right
                     6, 2, 1,
                     7, 6, 5, // Back
                     5, 4, 7,
                     4, 0, 3, // Left
                     3, 7, 4,
                     4, 5, 1, // Bottom
                     1, 0, 4,
                     3, 2, 6, // Top
                     6, 7, 3};

void main() {

    // Get the x, y and z position of the voxel
    int x = int(gl_WorkGroupID.x); // x will be the x value of dispatch
    int y = int(gl_LocalInvocationID.y); // y will be the y value of invocation
    int z = int(gl_LocalInvocationID.z); // z will be the z value of invocation

    // Determine this voxels world space location
    float xWS = chunk[0].pos.x + (x - ceil(gl_NumWorkGroups.x / 2.0));
    float yWS = chunk[0].pos.y + (y - ceil(gl_WorkGroupSize.y / 2.0));
    float zWS = chunk[0].pos.z + (z - ceil(gl_WorkGroupSize.z / 2.0));

    // The flattened position of the current invocation
    uint invocationPos = x + gl_WorkGroupSize.y * (y + gl_WorkGroupSize.z * z);

    // Check if the voxel isSolid
    Voxel currVoxel = voxels[invocationPos];
    if(currVoxel.isSolid == 1){

        // Initialize some structs
        Vertex v; // Init a vertex
        Colour c; // Init a colour

        int frontSolid = 0;
        int frontZPos = z + 1;
        if(frontZPos < gl_WorkGroupSize.z){
            frontSolid = voxels[int((x) + gl_WorkGroupSize.y * ((y) + gl_WorkGroupSize.z * (frontZPos)))].isSolid;
        }

        int backSolid = 0;
        int backZPos = z - 1;
        if(backZPos >= 0){
            backSolid = voxels[int((x) + gl_WorkGroupSize.y * ((y) + gl_WorkGroupSize.z * (backZPos)))].isSolid;
        }

        int leftSolid = 0;
        int leftXPos = x - 1;
        if(leftXPos >= 0){
            leftSolid = voxels[int((leftXPos) + gl_WorkGroupSize.y * ((y) + gl_WorkGroupSize.z * (z)))].isSolid;
        }

        int rightSolid = 0;
        int rightXPos = x + 1;
        if(rightXPos < gl_NumWorkGroups.x){
            rightSolid = voxels[int((rightXPos) + gl_WorkGroupSize.y * ((y) + gl_WorkGroupSize.z * (z)))].isSolid;
        }

        int botSolid = 0;
        int botYPos = y - 1;
        if(botYPos >= 0){
            botSolid = voxels[int((x) + gl_WorkGroupSize.y * ((botYPos) + gl_WorkGroupSize.z * (z)))].isSolid;
        }

        int topSolid = 0;
        int topYPos = y + 1;
        if(topYPos < gl_WorkGroupSize.y){
            topSolid = voxels[int((x) + gl_WorkGroupSize.y * ((topYPos) + gl_WorkGroupSize.z * (z)))].isSolid;
        }

        // Generate the Front Face (voxel_faces: 0, 1)
        if(frontSolid == 0){
            int frontFaceIndex = (0 * 3);
            for(int i = 0; i < 6; i++){

                int vertexIndex = voxel_faces[frontFaceIndex + i] * 3;

                Vertex v;
                v.x = voxel_vertices[vertexIndex] + xWS;
                v.y = voxel_vertices[vertexIndex+1] + yWS;
                v.z = voxel_vertices[vertexIndex+2] + zWS;

                Colour c;
                c.r = currVoxel.voxType/255.0f;
                c.g = currVoxel.voxType/255.0f;
                c.b = currVoxel.voxType/255.0f;
                c.a = currVoxel.voxType/255.0f;

                int vertexBufferPos = int((invocationPos * 36) + frontFaceIndex + i);
                vertices[vertexBufferPos] = v;
                vertex_colours[vertexBufferPos] = c;
            }
        }

        // Generate the Right Face (voxel_faces: 2, 3)
        if(rightSolid == 0){
            int rightFaceIndex = (2 * 3);
            for(int i = 0; i < 6; i++){

                int vertexIndex = voxel_faces[rightFaceIndex + i] * 3;

                Vertex v;
                v.x = voxel_vertices[vertexIndex] + xWS;
                v.y = voxel_vertices[vertexIndex+1] + yWS;
                v.z = voxel_vertices[vertexIndex+2] + zWS;

                Colour c;
                c.r = currVoxel.voxType/255.0f;
                c.g = currVoxel.voxType/255.0f;
                c.b = currVoxel.voxType/255.0f;
                c.a = currVoxel.voxType/255.0f;

                int vertexBufferPos = int((invocationPos * 36) + rightFaceIndex + i);
                vertices[vertexBufferPos] = v;
                vertex_colours[vertexBufferPos] = c;
            }
        }

        // Generate the Back Face (voxel_faces: 4, 5)
        if(backSolid == 0){
            int backFaceIndex = (4 * 3);
            for(int i = 0; i < 6; i++){

                int vertexIndex = voxel_faces[backFaceIndex + i] * 3;

                Vertex v;
                v.x = voxel_vertices[vertexIndex] + xWS;
                v.y = voxel_vertices[vertexIndex+1] + yWS;
                v.z = voxel_vertices[vertexIndex+2] + zWS;

                Colour c;
                c.r = currVoxel.voxType/255.0f;
                c.g = currVoxel.voxType/255.0f;
                c.b = currVoxel.voxType/255.0f;
                c.a = currVoxel.voxType/255.0f;

                int vertexBufferPos = int((invocationPos * 36) + backFaceIndex + i);
                vertices[vertexBufferPos] = v;
                vertex_colours[vertexBufferPos] = c;
            }
        }

        // Generate the Left Face (voxel_faces: 6, 7)
        if(leftSolid == 0){
            int leftFaceIndex = (6 * 3);
            for(int i = 0; i < 6; i++){

                int vertexIndex = voxel_faces[leftFaceIndex + i] * 3;

                Vertex v;
                v.x = voxel_vertices[vertexIndex] + xWS;
                v.y = voxel_vertices[vertexIndex+1] + yWS;
                v.z = voxel_vertices[vertexIndex+2] + zWS;

                Colour c;
                c.r = currVoxel.voxType/255.0f;
                c.g = currVoxel.voxType/255.0f;
                c.b = currVoxel.voxType/255.0f;
                c.a = currVoxel.voxType/255.0f;

                int vertexBufferPos = int((invocationPos * 36) + leftFaceIndex + i);
                vertices[vertexBufferPos] = v;
                vertex_colours[vertexBufferPos] = c;
            }
        }

        // Generate the Bottom Face (voxel_faces: 8, 9)
        if(botSolid == 0){
            int botFaceIndex = (8 * 3);
            for(int i = 0; i < 6; i++){

                int vertexIndex = voxel_faces[botFaceIndex + i] * 3;

                Vertex v;
                v.x = voxel_vertices[vertexIndex] + xWS;
                v.y = voxel_vertices[vertexIndex+1] + yWS;
                v.z = voxel_vertices[vertexIndex+2] + zWS;

                Colour c;
                c.r = currVoxel.voxType/255.0f;
                c.g = currVoxel.voxType/255.0f;
                c.b = currVoxel.voxType/255.0f;
                c.a = currVoxel.voxType/255.0f;

                int vertexBufferPos = int((invocationPos * 36) + botFaceIndex + i);
                vertices[vertexBufferPos] = v;
                vertex_colours[vertexBufferPos] = c;
            }
        }

        // Generate the Top Face (voxel_faces: 10, 11)
        if(topSolid == 0){
            int topFaceIndex = (10 * 3);
            for(int i = 0; i < 6; i++){

                int vertexIndex = voxel_faces[topFaceIndex + i] * 3;

                Vertex v;
                v.x = voxel_vertices[vertexIndex] + xWS;
                v.y = voxel_vertices[vertexIndex+1] + yWS;
                v.z = voxel_vertices[vertexIndex+2] + zWS;

                Colour c;
                c.r = currVoxel.voxType/255.0f;
                c.g = currVoxel.voxType/255.0f;
                c.b = currVoxel.voxType/255.0f;
                c.a = currVoxel.voxType/255.0f;

                int vertexBufferPos = int((invocationPos * 36) + topFaceIndex + i);
                vertices[vertexBufferPos] = v;
                vertex_colours[vertexBufferPos] = c;
            }
        }
    }
}